## 1.提炼函数
##### 好处：
避免出现超大函数。
独立出来的函数有助于代码复用。
独立出来的函数更容易被覆写。
独立出来的函数如果拥有一个良好的命名，它本身就起到了注释的作用。
语义化将多段分离的逻辑放在不同的函数中实现，可以使代码逻辑清晰，清楚的看到每一步在做什么。
##### 代码举例：
实现获取数据，然后操作dom显示数据，最后添加事件
* 函数提炼前
```javascript
// 逻辑都写在一起，需要将所有逻辑看完才知道这段代码是干嘛的，局部逻辑无法复用
function main() {
    $.ajax.get('/getData').then((res) => {
        const ul = document.getElementById('ul');
        ul.innerHTML = res.list.map(text => `<li class="li">${text}</li>`).join('\n');
        const list = document.getElementsByClassName('li');
        for (let i = 0; i < list.length; i ++) {
            list[i].addEventListener('focus', () => {
                // do something
            });
        }
    });
}
```
* 函数提炼后
  ```javascript
  function getData() {
    return $.ajax.get('/getData').then((res) => res.data.list);
    }
    function showList(list) {
        const ul = document.getElementById('ul');
        ul.innerHTML = list.map(text => `<li class="li">${text}</li>`).join('\n');
    }
    function addEvent() {
        const list = document.getElementsByClassName('li');
        for (let i = 0; i < list.length; i ++) {
            list[i].addEventListener('focus', () => {
                // do something
            });
        }
    }
    // 逻辑清晰，一眼读懂每一步在做什么，某些提炼出来的函数还可以被复用
    async function main() {
        const list = await getData(); // 获取数据
        showList(list); // 显示页面
        addEvent(); // 添加事件
    }
    ```
##  2.合并重复的条件片段
如果一个函数体内有一些条件分支语句，而这些条件分支语句内部散布了一些重复的代码，那么就有必要进行合并去重工作。
```javascript
// 合并前
function main( currPage ){
    if ( currPage <= 0 ){
        currPage = 0;
        jump( currPage ); // 跳转
    }else if ( currPage >= totalPage ){
        currPage = totalPage;
        jump( currPage ); // 跳转
    }else{
        jump( currPage ); // 跳转
    }
};

// 合并后
function main( currPage ){
    if ( currPage <= 0 ){
        currPage = 0;
    }else if ( currPage >= totalPage ){
        currPage = totalPage;
    }
    jump( currPage ); // 把jump 函数独立出来
};
```
##  3. 把条件分支语句提炼成函数
```javascript
// 根据不同季节决定打折力度
function getPrice( price ){
    var date = new Date();
    if ( date.getMonth() >= 6 && date.getMonth() <= 9 ){ // 夏天
        return price * 0.8;
    }
    return price;
};

// 是否是夏天
function isSummer(){
    var date = new Date();
    return date.getMonth() >= 6 && date.getMonth() <= 9;
};
// 提炼条件后
function getPrice( price ){
    if ( isSummer() ){
        return price * 0.8;
    }
    return price;
};
```
## 4.合理使用循环
```javascript
// 判断是什么浏览器
function getBrowser(){
    const str = navigator.userAgent;
    if (str.includes('QQBrowser')) {
 return 'qq';
    } else if (str.includes('Chrome')) {
 return 'chrome';
    } else if (str.includes('Safari')) {
        return 'safri';
    } else if (str.includes('Firefox')) {
        return 'firefox';
    } else if(explorer.indexOf('Opera') >= 0){
        return 'opera';
    } else if (str.includes('msie')) {
        return 'ie';
    } else {
        return 'other';
    }
};


// 循环判断，将对应关系抽象为配置，更加清晰明确
function getBrowser(){
    const str = navigator.userAgent;
    const list = [
        {key: 'QQBrowser', browser: 'qq'},
        {key: 'Chrome', browser: 'chrome'},
        {key: 'Safari', browser: 'safari'},
        {key: 'Firefox', browser: 'firefox'},
        {key: 'Opera', browser: 'opera'},
        {key: 'msie', browser: 'ie'},
    ];
    for (let i = 0; i < list.length; i++) {
        const item = list[i];
        if (str.includes(item.key)) {return item.browser};
    }
    return 'other';
```
## 5. 提前让函数退出代替嵌套条件分支
让函数变成多出口提前返回，替换嵌套条件分支。
```javascript
function del( obj ){
    var ret;
    if ( !obj.isReadOnly ){ // 不为只读的才能被删除
        if ( obj.isFolder ){ // 如果是文件夹
            ret = deleteFolder( obj );
        }else if ( obj.isFile ){ // 如果是文件
            ret = deleteFile( obj );
        }
    }
    return ret;
};

function del( obj ){
    if ( obj.isReadOnly ){ // 反转if 表达式
        return;
    }
    if ( obj.isFolder ){
        return deleteFolder( obj );
    }
    if ( obj.isFile ){
        return deleteFile( obj );
    }
};
```
## 6. 传递对象参数代替过长的参数列表

函数参数过长那么就增加出错的风险，想保证传递的顺序正确就是一件麻烦的事，代码可读性也会变差，尽量保证函数的参数不会太长。如果必须传递多个参数的话，建议使用**对象**代替。
一般来说，函数参数最好不要超过3个
```javascript
function setUserInfo( id, name, address, sex, mobile, qq ){
    console.log( 'id= ' + id );
    console.log( 'name= ' +name );
    console.log( 'address= ' + address );
    console.log( 'sex= ' + sex );
    console.log( 'mobile= ' + mobile );
    console.log( 'qq= ' + qq );
};
setUserInfo( 1314, 'sven', 'shenzhen', 'male', '137********', 377876679 );

function setUserInfo( obj ){
    console.log( 'id= ' + obj.id );
    console.log( 'name= ' + obj.name );
    console.log( 'address= ' + obj.address );
    console.log( 'sex= ' + obj.sex );
    console.log( 'mobile= ' + obj.mobile );
    console.log( 'qq= ' + obj.qq );
};
setUserInfo({
    id: 1314,
    name: 'sven',
    address: 'shenzhen',
    sex: 'male',
    mobile: '137********',
    qq: 377876679
});
```

## 7. 少用三目运算符

三目运算符性能高，代码量少。
但不应该滥用三目运算符，我们应该在简单逻辑分支使用，在复杂逻辑分支避免使用。
```javascript
// 简单逻辑可以使用三目运算符
var global = typeof window !== "undefined" ? window : this;

// 复杂逻辑不适合使用
var ok = isString ? (isTooLang ? 2 : (isTooShort ? 1 : 0)) : -1;
```

## 8. 合理使用链式调用

优点： 链式调用使用简单，代码量少。
缺点： 链式调用带来的坏处就是在调试不方便，如果我们知道一条链中有错误出现，必须得先把这条链拆开才能加上一些调试 log 或者增加断点，这样才能定位错误出现的地方。
如果该链条的结构相对稳定，后期不易发生修改，可以使用链式。
```javascript
var User = {
    id: null,
    name: null,
    setId: function( id ){
        this.id = id;
        return this;
    },
    setName: function( name ){
        this.name = name;
        return this;
    }
};
User
  .setId( 1314 )
  .setName( 'sven' );

var user = new User();
user.setId( 1314 );
user.setName( 'sven' );
```

## 9. 分解大型类

大型类的分解和函数的提炼很像，类太大会出现逻辑不清晰，难以理解和维护的问题。
合理的大类分解可以使类的逻辑清晰，且子模块可以方便复用。
## 10. 活用位操作符

编程语言计算乘除的性能都不高，但是某些情况使用位操作符可以提升乘除等运算的性能。

## 11. 纯函数

```纯函数```是指不依赖于且不改变它作用域之外的变量状态的函数。
纯函数的返回值只由它调用时的参数决定，它的执行不依赖于系统的状态（执行上下文）。
相同的输入参数，一定会得到相同的输出，也就是内部不含有会影响输出的随机变量。
##### 不属于纯函数的特点：
* 更改文件系统
* 往数据库插入记录
* 发送一个 http 请求
* 可变数据
* 打印/log
* 获取用户输入
* DOM 查询
* 访问系统状态
#### 纯函数的作用：
**可靠性**：函数返回永远和预期一致
**可缓存性**：因为只要输入一样输出一定一样，因此可将输入作为key，输出作为值，使用对象缓存已经计算的结果
**可移植性**：因为没有外部依赖，所以移植到任何环境都可正确运行
**可测试性**：方便针对函数做单元测试
**可并行性**：对一些复杂计算，可以并行计算（例如使用nodejs多个子进程同时并行计算多个任务，提高计算速度）
##### 应用场景：
* 工具函数最好使用纯函数
* 多平台使用的代码（nodejs、浏览器、微信小程序、native客户端等）
* 相对独立的功能

```javascript
    var a = 1;
    // 非纯函数
    function sum(b) {
        return a + b;
    }
    // 非纯函数
    function sum(b) {
        a = 2;
        return b;
    }
    // 非纯函数
    function sum(b) {
        return b + Math.random();
    }


    // 纯函数
    function sum (b, c) {
        return b + c;
    }
```
## 12.如何构造 if…else 语句以及如何用更少的代码实现
### 1. 小细节

不要使用否定条件式（这可能会让人感到疑惑）。同时，使用条件式简写来表示 boolean 值。这个无须再强调了，尤其是否定条件式，这不符合正常的思维方式。

不好的：
```javascript
const isEmailNotVerified = (email) => {
    // 实现
}

if (!isEmailNotVerified(email)) {
    // 做一些事...
}

if (isVerified === true) {
    // 做一些事...
}
```
好的：
```javascript
const isEmailVerified = (email) => {
    // 实现
}

if (isEmailVerified(email)) {
    // 做一些事...
}

if (isVerified) {
    // 做一些事...
}
```
### 2. 对于多个条件，使用 Array.includes

假设我们想要在函数中检查汽车模型是 renault 还是 peugeot。那么代码可能是这样的：
```javascript
const checkCarModel = (model) => {
    if(model === 'renault' || model === 'peugeot') { 
    console.log('model valid');
    }
}

checkCarModel('renault'); // 输出 'model valid'
```
考虑到我们只有两个模型，这么做似乎也还能接受，但如果我们还想要检查另一个或者是几个模型呢？如果我们增加更多 or 语句，那么代码将变得难以维护，且不够整洁。为了让它更加简洁，我们可以像这样重写函数：
```javascript
const checkCarModel = (model) => {
    if(['peugeot', 'renault'].includes(model)) { 
    console.log('model valid');
    }
}

checkCarModel('renault'); // 输出 'model valid'
```
上面的代码看起来已经很漂亮了。为了更进一步改善它，我们可以创建一个变量来存放汽车模型：
```javascript
const checkCarModel = (model) => {
    const models = ['peugeot', 'renault'];

    if(models.includes(model)) { 
    console.log('model valid');
    }
}

checkCarModel('renault'); // 输出 'model valid'
```
现在，如果我们想要检查更多模型，只需要添加一个新的数组元素即可。此外，如果它很重要的话，我们还可以将 models 变量定义在函数作用域外，并在需要的地方重用。这种方式可以让我们集中管理，并使维护变得轻而易举，因为我们只需在代码中更改一个位置。
### 3. 匹配所有条件，使用 Array.every 或者 Array.find

在本例中，我们想要检查每个汽车模型是否都是传入函数的那一个。为了以更加命令式的方式实现，我们会这么做：
```javascript
const cars = [
  { model: 'renault', year: 1956 },
  { model: 'peugeot', year: 1968 },
  { model: 'ford', year: 1977 }
];

const checkEveryModel = (model) => {
  let isValid = true;

  for (let car of cars) {
    if (!isValid) {
      break;
    }
    isValid = car.model === model;
  }

  return isValid;
}

console.log(checkEveryModel('renault')); // 输出 false
```
如果你更喜欢以命令式的风格行事，上面的代码或许还不错。另一方面，如果你不关心其背后发生了什么，那么你可以重写上面的函数并使用 
Array.every 或者 Array.find 来达到相同的结果。
```javascript
const checkEveryModel = (model) => {
  return cars.every(car => car.model === model);
}

console.log(checkEveryModel('renault')); // 输出 false
```
通过使用 Array.find 并做轻微的调整，我们可以达到相同的结果。两者的表现是一致的，因为两个函数都为数组中的每一个元素执行了回调，并且在找到一个 falsy 项时立即返回 false。
```javascript
const checkEveryModel = (model) => {
  return cars.find(car => car.model !== model) === undefined;
}

console.log(checkEveryModel('renault')); // 输出 false
```
### 4. 匹配部分条件，使用 Array.some

Array.every 匹配所有条件，这个方法则可以轻松地检查我们的数组是否包含某一个或某几个元素。为此，我们需要提供一个回调并基于条件返回一个布尔值。

我们可以通过编写一个类似的 for…loop 语句来实现相同的结果，就像之前写的一样。但幸运的是，有很酷的 JavaScript 函数可以来帮助我们完成这件事。
```javascript
const cars = [
  { model: 'renault', year: 1956 },
  { model: 'peugeot', year: 1968 },
  { model: 'ford', year: 1977 }
];

const checkForAnyModel = (model) => {
  return cars.some(car => car.model === model);
}

console.log(checkForAnyModel('renault')); // 输出 true
```
### 5. 提前返回而不是使用 if…else 分支

当我还是学生的时候，就有人教过我：一个函数应该只有一个返回语句，并且只从一个地方返回。如果细心处理，这个方法倒也还好。我这么说也就意味着，我们应该意识到它在某些情况下可能会引起条件式嵌套地狱。如果不受控制，多个分支和 if…else 嵌套将会让我们感到很痛苦。

另一方面，如果代码库很大且包含很多行代码，位于深层的一个返回语句可能会带来问题。现在我们都实行关注点分离和 SOLID 原则，因此，代码行过多这种情况挺罕见的。

举例来解释这个问题。假设我们想要显示所给车辆的模型和生产年份：
```javascript
const checkModel = (car) => {
  let result; // 首先，定义一个 result 变量

  // 检查是否有车
  if(car) {

    // 检查是否有车的模型
    if (car.model) {

      // 检查是否有车的年份
      if(car.year) {
        result = `Car model: ${car.model}; Manufacturing year: ${car.year};`;
      } else {
        result = 'No car year';
      }

    } else {
      result = 'No car model'
    }   

  } else {
    result = 'No car';
  }

  return result; // 我们的单独的返回语句
}

console.log(checkModel()); // 输出 'No car'
console.log(checkModel({ year: 1988 })); // 输出 'No car model'
console.log(checkModel({ model: 'ford' })); // 输出 'No car year'
console.log(checkModel({ model: 'ford', year: 1988 })); // 输出 'Car model: ford; Manufacturing year: 1988;'
```
正如你所看到的，即使本例的问题很简单，上面的代码也实在太长了。可以想象一下，如果我们有更加复杂的逻辑会发生什么事。大量的 if…else 语句。

我们可以重构上面的函数，分解成多个步骤并稍做改善。例如，使用三元操作符，包括 && 条件式等。不过，这里我直接跳到最后，向你展示借助现代 JavaScript 特性和多个返回语句，代码可以有多简洁。
```javascript
const checkModel = ({model, year} = {}) => {
  if(!model && !year) return 'No car';
  if(!model) return 'No car model';
  if(!year) return 'No car year';

  // 这里可以任意操作模型或年份
  // 确保它们存在
  // 无需更多检查

  // doSomething(model);
  // doSomethingElse(year);

  return `Car model: ${model}; Manufacturing year: ${year};`;
}

console.log(checkModel()); // 输出 'No car'
console.log(checkModel({ year: 1988 })); // 输出 'No car model'
console.log(checkModel({ model: 'ford' })); // 输出 'No car year'
console.log(checkModel({ model: 'ford', year: 1988 })); // 输出 'Car model: ford; Manufacturing year: 1988;'
```
在重构版本中，我们包含了解构和默认参数。默认参数确保我们在传入 undefined 时有可用于解构的值。注意，如果传入 null ，函数将会抛出错误。这也是之前那个方法的优点所在，因为那个方法在传入 null 的时候会输出 ‘No car’。

对象解构确保函数只取所需。例如，如果我们在给定车辆对象中包含额外属性，则该属性在我们的函数中是无法获取的。

根据偏好，开发者会选择其中一种方式。实践中，编写的代码通常介于两者之间。很多人觉得 if…else 语句更容易理解，并且有助于他们更为轻松地遵循程序流程。

### 6. 使用索引或者映射，而不是 switch 语句

假设我们想要基于给定的国家获取汽车模型。
```javascript
const getCarsByState = (state) => {
  switch (state) {
    case 'usa':
      return ['Ford', 'Dodge'];
    case 'france':
      return ['Renault', 'Peugeot'];
    case 'italy':
      return ['Fiat'];
    default:
      return [];
  }
}

console.log(getCarsByState()); // 输出 []
console.log(getCarsByState('usa')); // 输出 ['Ford', 'Dodge']
console.log(getCarsByState('italy')); // 输出 ['Fiat']
```

上诉代码可以重构，完全去除 switch 语句。

```javascript
const cars = new Map()
  .set('usa', ['Ford', 'Dodge'])
  .set('france', ['Renault', 'Peugeot'])
  .set('italy', ['Fiat']);

const getCarsByState = (state) => {
  return cars.get(state) || [];
}

console.log(getCarsByState()); // 输出 []
console.log(getCarsByState('usa')); //输出 ['Ford', 'Dodge']
console.log(getCarsByState('italy')); // 输出 ['Fiat']
或者，我们还可以为包含可用汽车列表的每个国家创建一个类，并在需要的时候使用。不过这个就是题外话了，本文的主题是关于条件句的。更恰当的修改是使用对象字面量。

const carState = {
  usa: ['Ford', 'Dodge'],
  france: ['Renault', 'Peugeot'],
  italy: ['Fiat']
};

const getCarsByState = (state) => {
  return carState[state] || [];
}

console.log(getCarsByState()); // 输出 []
console.log(getCarsByState('usa')); // 输出 ['Ford', 'Dodge']
console.log(getCarsByState('france')); // 输出 ['Renault', 'Peugeot']
```

### 7. 使用自判断链接和空合并


让我们用一些例子来支撑上面的结论。一开始，我们还是用以前的老方法：

```javascript
const car = {
  model: 'Fiesta',
  manufacturer: {
    name: 'Ford',
    address: {
      street: 'Some Street Name',
      number: '5555',
      state: 'USA'
    }
  }
}

// 获取汽车模型
const model = car && car.model || 'default model';
// 获取厂商地址
const street = car && car.manufacturer && car.manufacturer.address && car.manufacturer.address.street || 'default street';
// 请求一个不存在的属性
const phoneNumber = car && car.manufacturer && car.manufacturer.address && car.manufacturer.phoneNumber;

console.log(model) // 输出 'Fiesta'
console.log(street) // 输出 'Some Street Name'
console.log(phoneNumber) // 输出 undefined
因此，如果我们想要知道厂商是否来自 USA 并将结果打印，那么代码是这样的：

const checkCarManufacturerState = () => {
  if(car && car.manufacturer && car.manufacturer.address && car.manufacturer.address.state === 'USA') {
    console.log('Is from USA');
  }
}

checkCarManufacturerState() // 输出 'Is from USA'
```

我们来看一下新的方法：

```javascript
    // 获取汽车模型
    const model = car?.model ?? 'default model';
    // 获取厂商地址
    const street = car?.manufacturer?.address?.street ?? 'default street';

    // 检查汽车厂商是否来自 USA
    const checkCarManufacturerState = () => {
      if(car?.manufacturer?.address?.state === 'USA') {
        console.log('Is from USA');
      }
    }
```    
使用 ?? 而不是 || 。

自判断链接同样支持 DOM API，意味着你可以这么做：
```javascript
const value = document.querySelector('input#user-name')?.value;
```

## 13.确保数组的长度
```javascript
let array =Array(5).fill('');
console.log(array);// 输出（5）["", "", "", "", ""]
```
## 14. 数组去重

ES6 提供了几种非常简洁的数组去重的方法。但不幸的是，它们并不适合处理非基本类型的数组。稍后你可以在棘手的数组去重一文中读到更多有关它的信息。这里我们只关注基本类型的数组去重。
```javascript
const cars =['Mazda','Ford','Renault','Opel','Mazda']
const uniqueWithArrayFrom =Array.from(new Set(cars));
console.log(uniqueWithArrayFrom);// 输出 ["Mazda", "Ford", "Renault", "Opel"]
const uniqueWithSpreadOperator = [...new Set(cars)];
console.log(uniqueWithSpreadOperator);
// 输出 ["Mazda", "Ford", "Renault", "Opel"]
```
## 15. 用扩展运算符合并对象和对象数组

合并对象并不是一个罕见的问题，你很有可能已经遇到过这个问题，并且在不远的未来还会再次遇到。不同的是，在过去你手动完成了大部分工作，但从现在开始，你将使用 ES6 的新功能。
```javascript
// 合并对象
const product ={name:'Milk',packaging:'Plastic',price:'5$'}
const manufacturer ={name:'Company Name',address:'TheCompany Address' }
const productManufacturer ={...product,...manufacturer};
console.log(productManufacturer);
// 输出 { name: "Company Name", packaging: "Plastic", price: "5$", address: "The Company Address" }
// 将对象数组合并成一个对象
const cities =[{name:'Paris', visited:'no'},{name:'Lyon',visited:'no'},{name:'Marseille', visited:'yes'},{ name:'Rome', visited:'yes'}];
const result = cities.reduce((accumulator, item)=>{  
    return{  
    ...accumulator,   
    [item.name]:item.visited}
    },{});
    console.log(result);
/* 输出
Berlin: "no"
Genoa: "yes"
Hamburg: "yes"
Lyon: "no"
Marseille: "yes"
Milan: "no"
New York: "yes"
Palermo: "yes"
Paris: "no"
Rome: "yes"
*/
```
## 16. 数组映射（不使用 Array.map）

你知道这里有另外一种方法可以实现数组映射，而不使用 Array.map 吗？如果不知道，请继续往下看。
```javascript
const cities = [{ name: 'Paris', visited: 'no' },{ name: 'Lyon', visited: 'no' },{ name: 'Marseille', visited: 'yes' },{ name: 'Rome', visited: 'yes' },
{ name: 'Milan', visited: 'no' },{ name: 'Palermo', visited: 'yes' },{ name: 'Genoa', visited: 'yes' },{ name: 'Berlin', visited: 'no' },{ name: 'Hamburg', visited: 'yes' },{ name: 'New York', visited: 'yes' }];
const cityNames = Array.from(cities, ({ name}) => name);
console.log(cityNames);
// 输出 ["Paris", "Lyon", "Marseille", "Rome", "Milan", "Palermo", "Genoa", "Berlin", "Hamburg", "New York"]
```

## 17. 根据条件添加对象属性

现在，你不再需要根据条件创建两个不同的对象，以使其具有特定属性。扩展操作符将是一个完美的选择。

```javascript
const getUser = (emailIncluded) => {
    return {
    name: 'John',
    surname: 'Doe',
    ...emailIncluded ? { email : 'john@doe.com' } :null
    }
}
    const user = getUser(true);
    console.log(user); // 输出 { name: "John", surname: "Doe", email: "john@doe.com" }
    const userWithoutEmail = getUser(false);
    console.log(userWithoutEmail); // 输出 { name: "John", surname: "Doe" 

```

##  18.解构原始数据

```javascript
    const rawUser = {
    name: 'John',
    surname: 'Doe',
    email: 'john@doe.com',
    displayName: 'SuperCoolJohn',
    joined: '2016-05-05',
    image: 'path-to-the-image',
    followers: 45
    ...
    }
```

通过把上面的对象分成两个，我们可以用更能传递上下文含义的方式来表示这个对象，如下所示：

```javascript
    let user = {}, userDetails = {};
    ({ name: user.name, surname: user.surname, ...userDetails } = rawUser);
    console.log(user); // 输出 { name: "John", surname: "Doe" }
    console.log(userDetails); // 输出 { email: "john@doe.com", displayName: "SuperCoolJohn", joined: "2016-05-05", image: "path-to-the-image", followers: 45 }
```

## 19. 动态设置对象属性名
在过去，如果我们需要动态设置对象的属性名，我们必须首先声明一个对象，然后再给它分配一个属性。这不可能以单纯声明的方式实现。今时不同往日，现在我们可以通过 ES6 的功能实现这一目标。
```javascript
    const dynamic = 'email';
    let user = {
        name: 'John',
        [dynamic]: 'john@doe.com'
    }
    console.log(user); // 输出 { name: "John", email: "john@doe.com" }
```
## 20. 字符串插值
最后尤为重要的是拼接字符串的新方法。如果你想在一个辅助程序中构建模版字符串，这会非常有用。它使动态连接字符串模版变得更简单了。
```javascript
    const user = {
    name: 'John',
    surname: 'Doe',
    details: {
        email: 'john@doe.com',
        displayName: 'SuperCoolJohn',
        joined: '2016-05-05',
        image: 'path-to-the-image',
        followers: 45
    }
    }
    const printUserInfo = (user) => { 
    const text = `The user is ${user.name} ${user.surname}. Email: ${user.details.email}. Display Name: ${user.details.displayName}. ${user.name} has ${user.details.followers} followers.`
    console.log(text);
    }
    printUserInfo(user);
    // 输出 'The user is John Doe. Email: john@doe.com. Display Name: SuperCoolJohn. John has 45 followers.'
```
## 21.小技巧
### 使用!!操作符转换布尔值
对于变量可以使用!!variable做检测，只要变量的值为:0、null、" "、undefined或者NaN都将返回的是false，反之返回的是true。

### 使用+将字符串转换成数字

### 并条件符

使用||运算符

在ES6中有默认参数这一特性。为了在老版本的浏览器中模拟这一特性，可以使用||操作符，并且将将默认值当做第二个参数传入。如果第一个参数返回的值为false，那么第二个值将会认为是一个默认值。如下面这个示例：

```javascript
function User(name, age) {
    this.name = name || "Oliver Queen";
    this.age = age || 27;
}
var user1 = new User();
console.log(user1.name); // Oliver Queen
console.log(user1.age); // 27
 
var user2 = new User("Barry Allen", 25);
console.log(user2.name); // Barry Allen
console.log(user2.age); // 25
```

### 在循环中缓存array.length

处理的是一个大的数组
```javascript
var length = array.length;
for(var i = 0; i < length; i++) {
    console.log(array[i]);
}
```

### 检测对象中属性

当你需要检测一些属性是否存在，避免运行未定义的函数或属性时，这个小技巧就显得很有用。如果你打算定些一些跨兼容的浏览器代码，你也可能会用到这个小技巧。例如，你想使用document.querySelector()来选择一个id，并且让它能兼容IE6浏览器，但是在IE6浏览器中这个函数是不存在的，那么使用这个操作符来检测这个函数是否存在就显得非常的有用，如下面的示例：
```javascript
//if in
if ('querySelector' in document) {
    document.querySelector("#id");
} else {
    document.getElementById("id");
}
```
在这个示例中，如果document不存在querySelector函数，那么就会调用docuemnt.getElementById("id")。

### 获取数组中最后一个元素

Array.prototype.slice(begin,end)用来获取begin和end之间的数组元素。如果你不设置end参数，将会将数组的默认长度值当作end值。但有些同学可能不知道这个函数还可以接受负值作为参数。如果你设置一个负值作为begin的值，那么你可以获取数组的最后一个元素。如：

```javascript
var array = [1,2,3,4,5,6];
console.log(array.slice(-1)); // [6]
console.log(array.slice(-2)); // [5,6]
console.log(array.slice(-3)); // [4,5,6]
```
### 数组截断

这个小技巧主要用来锁定数组的大小，如果用于删除数组中的一些元素来说，是非常有用的。例如，你的数组有10个元素，但你只想只要前五个元素，那么你可以通过array.length=5来截断数组。如下面这个示例：

```javascript
var array = [1,2,3,4,5,6];
console.log(array.length); // 6
array.length = 3;
console.log(array.length); // 3
console.log(array); // [1,2,3]
```

### 替换所有

String.replace()函数允许你使用字符串或正则表达式来替换字符串，本身这个函数只替换第一次出现的字符串，不过你可以使用正则表达多中的/g来模拟replaceAll()函数功能：

```javascript
var string = "john john";
console.log(string.replace(/hn/, "ana")); // "joana john"
console.log(string.replace(/hn/g, "ana")); // "joana joana"
```

### 合并数组

如果你要合并两个数组，一般情况之下你都会使用Array.concat()函数：
```javascript
var array1 = [1,2,3];
var array2 = [4,5,6];
console.log(array1.concat(array2)); // [1,2,3,4,5,6];
```
然后这个函数并不适合用来合并两个大型的数组，因为其将消耗大量的内存来存储新创建的数组。在这种情况之个，可以使用Array.push().apply(arr1,arr2)来替代创建一个新数组。这种方法不是用来创建一个新的数组，其只是将第一个第二个数组合并在一起，同时减少内存的使用：
```javascript
var array1 = [1,2,3];
var array2 = [4,5,6];
console.log(array1.push.apply(array1, array2)); // [1,2,3,4,5,6];
```
### 将NodeList转换成数组

如果你运行document.querySelectorAll(“p”)函数时，它可能返回DOM元素的数组，也就是NodeList对象。但这个对象不具有数组的函数功能，比如sort()、reduce()、map()、filter()等。为了让这些原生的数组函数功能也能用于其上面，需要将节点列表转换成数组。可以使用[].slice.call(elements)来实现：
```javascript
var elements = document.querySelectorAll("p"); // NodeList
var arrayElements = [].slice.call(elements); // Now the NodeList is an array
var arrayElements = Array.from(elements); // This is another way of converting NodeList to Array
```

### 数组元素的洗牌

对于数组元素的洗牌，不需要使用任何外部的库，比如Lodash，只要这样做：
```javascript
var list = [1,2,3];
console.log(list.sort(function() { Math.random() - 0.5 })); // [2,1,3]
```
## 规范
1. 写代码，无需原始开发者的帮助，写代码要让任何人一看代码就知道它是在干什么，以及它是怎么实现的。
2. 写代码✍，要符合逻辑，无论操作有多么复杂，代码中的一切都要顺理成章。
3. 要重点思考，写代码，当使用数据发生变化时，也不用重写。
4. 要经过设计（代码架构），能够支持以后的扩展核心功能。
5. 要让自己或别人能够容易进行调试，能让代码可以给出明确的信息，可以通过调试定位问题。
6. 学习前要注重代码编写规范，要让代码容易维护，具有可读性。
7. 注意写注解，在函数和方法地方描述其用途，完成任务所用到的算法。在大型代码块中，复杂的算法中，加入注解。
8. 代码中变量和函数的适当命名对于其可读性和可维护性至关重要的。如变量名应该是名词，函数名应该是动词，返回布尔值的函数常以is开头，对变量和函数都使用符合逻辑的名称（长度适当），变量，函数和方法应该以小写字母开头，使用驼峰大小写形式，类名应该首字母 大写，常量值应该全部大写并以下划线相接，名称要尽量具有描述性和直观。

【参考】
1. https://mp.weixin.qq.com/s/fpxZQQNjgPGDVI4i-eCXjQ
2. https://mp.weixin.qq.com/s/YkYvZDbHb77_ImbBe3JbrQ